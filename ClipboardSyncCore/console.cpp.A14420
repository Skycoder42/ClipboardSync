#include "console.h"
#include <QTextStream>
#include <QCoreApplication>
#include <iostream>

QPointer<Console> Console::consoleInstance;

Console::Console(QObject *parent) :
	QThread(parent),
	qOut(new QFile(this)),
	qErr(new QFile(this))
{
	connect(this, &Console::finished,
			qApp, &QCoreApplication::quit,
			Qt::QueuedConnection);

	this->setTerminationEnabled(true);
	this->start();

	this->qOut->open(stdout, QIODevice::WriteOnly);
	this->qErr->open(stderr, QIODevice::WriteOnly);
}

Console::~Console()
{
	this->qOut->close();
	this->qErr->close();

	if(this->isRunning())
		this->terminate();
}

void Console::installAsMessageHandler()
{
	consoleInstance = this;
	qInstallMessageHandler(consoleMessage);
}

bool Console::autoExit() const
{
	return this->autoQuit;
}

void Console::writeMessage(bool isError, const QString &message, bool lineFeed)
{
	QFile *file;
	if(isError)
		file = this->qErr;
	else
		file = this->qOut;

	file->write(message.toUtf8());
	if(lineFeed) {
		file->write("\n");
		file->flush();
	}
}

void Console::setAutoExit(bool autoExit)
{
	this->autoQuit = autoExit;
}

void Console::run()
{
	QFile inFile;
	inFile.open(stdin, QIODevice::ReadOnly);

	forever {
		auto command = QString::fromUtf8(inFile.readLine()).trimmed();
		if(this->autoQuit && command == QStringLiteral("exit"))
			break;
		else {
			QMetaObject::invokeMethod(this, "commandReceived", Qt::QueuedConnection,
									  Q_ARG(QString, command));
		}
	}

	inFile.close();
}

void Console::consoleMessage(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
	Q_UNUSED(context);
	if(consoleInstance) {
		consoleInstance->writeMessage(type != QtMsgType::QtInfoMsg, msg);
	} else
		std::cerr << "CONSOLE DESTROYED! ORIGINAL MESSAGE:" << msg.toUtf8().constData();
}
